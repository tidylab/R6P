---
title: "The Repository Pattern"
bibliography: [../../inst/REFERENCES.bib]
biblio-style: apalike
link-citations: yes
editor_options: 
  markdown: 
    wrap: 80
---

```{r, include = FALSE}
source(file.path(usethis::proj_get(), "vignettes",  "_common.R"))
```

## How It Works

See [@Fowler2002, p. 322]

```{r}
path_snippet <- usethis::proj_path("R", "object_relational-Repository.R")
snippet <- readLines(path_snippet)
snippet <- snippet[!snippet %>% stringr::str_detect("^(#'|#) ")]
```

```{r, code = snippet, eval = FALSE, echo = TRUE}
```

## Implementations

The minimal implementing of `AbstractRepository` requires you to define four
functions:

(1) `initialize`,
(2) `add`,
(3) `del`, and
(4) `get`.

<!-- In addition, there are context depended function you may want to ad -->

Importantly, any Repository implementation happens in context. The following
implementations consider a repostory of car models with their specifications.

### In-Memory Storage with [`collections`](https://github.com/randy3k/collections)

```{r, message=TRUE}
message("In-Memory implementations are a temporal solution that is good for testing and rapid prototyping.")
```

1.  In-Memory implementations contribute to rapid development because:

-   They can be used before you establish/get access to a real database.
-   They are fast to establish in comparison to DBMS

2.  In-Memory implementations are useful during testing because they are
    independent of the real database (if any), that means:

-   They start as empty storage allowing the programmer to test specific
    behaviour of the caller.
-   They don't make unintended changes in the real database

```{r, error=TRUE}
stop("In-Memory implementations are not recommended during the production stage. In-Memory storage are lost when a session is rebooted. You should think about what are the ramifications of losing all the data put into storage.")
```

-   See more information about `collections::dict` in
    [appendix](#appendix-dict).

```{r Repository-In-Memory-implementation, echo=TRUE, results='markup'}
InMemoryRepository <- R6::R6Class(
  classname = "Repository", inherit = AbstractRepository, public = list(
    initialize = function() private$cars <- collections::dict(),
    add = function(key, value){private$cars$set(key, value); invisible(self)},
    del = function(key){private$cars$remove(key); invisible(self)},
    get = function(key){return(private$cars$get(key, default = NULL))}
  ), private = list(
    cars = NULL)
)
```

Adding customised operations

```{r Repository-In-Memory-implementation-addon, echo=TRUE, results='markup'}
InMemoryRepository$set("public", "get_all_cars", overwrite = TRUE, function(){
  private$cars$values() %>% dplyr::bind_rows()
})
```

```{r, echo=TRUE, results='markup'}
repository <- InMemoryRepository$new()

repository$add(key = rownames(mtcars[1,]), value = mtcars[1,])
repository$add(key = rownames(mtcars[2,]), value = mtcars[2,])

repository$get(key = rownames(mtcars[1,]))

repository$get_all_cars()

repository$del(key = rownames(mtcars[1,]))
repository$get(key = rownames(mtcars[1,]))
```

-   Talk about each line
-   Talk about additional functions

### Persistent Storage with [`DBI`](https://dbi.r-dbi.org/) 

```{r Repository-Persistent-implementation, echo=TRUE}
PersistentRepository <- R6::R6Class(
    classname = "Repository", inherit = AbstractRepository, public = list(
        #' @param immediate (`logical`) Should queries be committed immediately?
        initialize = function(immediate = TRUE){
            private$immediate <- immediate
            private$conn <- DBI::dbConnect(RSQLite::SQLite(), dbname = ":memory:")
            private$NULL_car <-
                datasets::mtcars[0,] %>%
                tibble::add_column(uid = NA_character_, .before = 0)
            DBI::dbCreateTable(private$conn, "mtcars", private$NULL_car)
        },
        add = function(key, value){
            value <- private$NULL_car %>% tibble::add_row(uid = key, value)
            self$del(key = key)
            DBI::dbAppendTable(private$conn, "mtcars", value)
            invisible(self)
        },
        del = function(key){
            statement <- paste0("DELETE FROM mtcars WHERE uid = '", key, "'")
            DBI::dbExecute(private$conn, statement, immediate = private$immediate)
            invisible(self)
        },
        get = function(key){
            statement <- paste0("SELECT * FROM mtcars WHERE uid = '", key, "'")
            result <- DBI::dbGetQuery(private$conn, statement)
            if(nrow(result) == 0) return(NULL) else return(result)
        }
    ), private = list(
        immediate = NULL,
        NULL_car = NULL,
        conn = NULL)
)
```

Adding customised operations

```{r Repository-Persistent-implementation-addon, echo=TRUE}
PersistentRepository$set("public", "get_all_cars", overwrite = TRUE, function(){
    statement <- "SELECT * FROM mtcars"
    result <- DBI::dbGetQuery(private$conn, statement)
    if(nrow(result) == 0) return(NULL) else return(result)
})
```

```{r, echo=TRUE, results='markup'}
repository <- PersistentRepository$new()

repository$add(key = rownames(mtcars[1,]), value = mtcars[1,])
repository$add(key = rownames(mtcars[2,]), value = mtcars[2,])

repository$get(key = rownames(mtcars[1,]))

repository$get_all_cars()

repository$del(key = rownames(mtcars[1,]))
repository$get(key = rownames(mtcars[1,]))
```



<!-- ## References -->
