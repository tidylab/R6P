---
title: "The Null Object Pattern"
editor_options: 
  markdown: 
    wrap: 80
---

```{r, include = FALSE}
source(file.path(usethis::proj_get(), "vignettes",  "_common.R"))
```

```{r, error=TRUE}
events$stop_not_useful("NullObject")
```

<!-- One line about what the function does -->

***Null Object*** ...

```{r warning=TRUE}
warning("The Null Object is not the same as the reserved word in R `NULL` (all caps).")
```

## How It Works

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed a lacinia erat.
Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere cubilia
curae; Nam vitae tempor sem. Nullam vel augue suscipit, scelerisque nisl eu,
suscipit mi. Etiam sit amet turpis vitae massa facilisis tincidunt. Mauris
suscipit venenatis tincidunt. Ut convallis augue ac orci pulvinar, vestibulum
bibendum nibh vestibulum. In sed leo arcu. Proin eget magna porttitor, ultrices
tortor auctor, luctus ligula. Vestibulum ante ipsum primis in faucibus orci
luctus et ultrices posuere cubilia curae; Proin consequat dignissim dictum.

## When to Use It

-   In situations when a subroutine is likely to fail, such as loss of Internet
    or database connectivity. Instead of prompting a run-time error, you could
    return the **Null Object** as part of a [gracefully
    failing](https://en.wikipedia.org/wiki/Graceful_exit) strategy. A common
    strategy employs `tryCatch` that returns the **Null Object** in the case of 
    an error:

```{r, echo = TRUE, eval = TRUE}
# Mock that simulated a database that is 5% likely to fail 
read_mtcars <- function() if(runif(1) < 0.05) stop() else return(mtcars)

# mtcars null object constructor
NullCar <- function() mtcars[0,]

# How does the null car object look like? 
NullCar()

# Subroutine with gracefully failing strategy
set.seed(1814)
cars <- tryCatch(
  # Try reading the mtcars dataset
  read_mtcars(), 
  # If there is an error, return the Null Car object
  error = function(e) return(NullCar()) 
)

# Notice: Whether the subroutine fails or succeeds, it returns a tibble with 
# the same structure.
colnames(cars)
```

-   In unit-tests

```{r, echo = TRUE, eval = FALSE}
classes <- function(x) sapply(x, class)
    
test_that("mtcars follows a certain table structure", {
    # Compare column names
    expect_identical(colnames(mtcars), colnames(NullCar()))
    # Compare variable types
    expect_identical(classes(mtcars), classes(NullCar()))
})
```
